/*
University of Washington, Tacoma
TCSS 360 Software Development and Quality Assurance Techniques

Instructor: Tom Capaul
Academic Quarter: Summer 2021
Assignment: Group Project
Team members: Raz Consta, Reuben Keller, Dustin Ray
 */

package model.room;

import model.graph.*;
import org.junit.jupiter.api.Test;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Implements unit tests for RoomBuilder.
 *
 * @author Reuben Keller
 * @version Summer 2021
 */
public class RoomBuilderTest {

    /** The number of rows for customRB. */
    private static final int NUM_ROWS = 3;

    /** The number of columns for customRB. */
    private static final int NUM_COLS = 3;

    /** The source for customRB. */
    private static final int SOURCE = 0;

    /** The target for customRB. */
    private static final int TARGET = 8;

    /** A RoomBuilder constructed with the default parameters of the class. */
    private final RoomBuilder defaultRB;

    /** A custom RoomBuilder constructed using the constants of this class. */
    private final RoomBuilder customRB;

    /** The Graph generated by defaultRB. */
    private final Graph<Integer> defaultGraph;

    /** The Graph generated by customRB. */
    private final Graph<Integer> customGraph;

    /** An MST finder to run on the Graphs. */
    private final KruskalMSTFinder<Integer> mstFinder;

    /** A shortest path finder to run on the Graphs. */
    private final DijkstraSPFinder<Integer> spFinder;


    /**
     * Constructs a RoomBuilderText, initializing test fields.
     */
    public RoomBuilderTest() {
        defaultRB = new RoomBuilder();
        customRB = new RoomBuilder(NUM_ROWS, NUM_COLS, SOURCE, TARGET);
        mstFinder = new KruskalMSTFinder<>();
        spFinder = new DijkstraSPFinder<>();
        defaultGraph = defaultRB.getGraph();
        customGraph = customRB.getGraph();
    }


    /**
     * Checks that the arg constructor throws an IllegalArgumentException when
     * given a negative.
     */
    @Test
    void argConstructor_givenNegative_throwsException() {
        String msg = "arg constructor should throw exception for" +
                "a negative parameter";
        assertThrows(IllegalArgumentException.class,
                () -> new RoomBuilder(0, 0, 0, -1),
                msg);
        assertThrows(IllegalArgumentException.class,
                () -> new RoomBuilder(0, 0, -1, 0),
                msg);
        assertThrows(IllegalArgumentException.class,
                () -> new RoomBuilder(0, -1, 0, 0),
                msg);
        assertThrows(IllegalArgumentException.class,
                () -> new RoomBuilder(-1, 0, 0, 0),
                msg);
    }


    /**
     * Checks that getNumRows() returns the correct number of rows.
     */
    @Test
    void getNumRows_onCustomRoomBuilder_returnsCorrect() {
        assertEquals(NUM_ROWS, customRB.getNumRows(),
                "getNumRows() does not return correct number of rows");
    }


    /**
     * Checks that getNumCols() returns the correct number of columns.
     */
    @Test
    void getNumCols_onCustomRoomBuilder_returnsCorrect() {
        assertEquals(NUM_COLS, customRB.getNumCols(),
                "getNumCols() does not return correct number of columns");
    }


    /**
     * Checks that getSource() returns the correct source.
     */
    @Test
    void getSource_onCustomRoomBuilder_returnsCorrect() {
        assertEquals(SOURCE, customRB.getSource(),
                "getSource() does not return correct source");
    }


    /**
     * Checks that getTarget() returns the correct target.
     */
    @Test
    void getTarget_onCustomRoomBuilder_returnsCorrect() {
        assertEquals(TARGET, customRB.getTarget(),
                "getTarget() does not return correct target");
    }


    /**
     * Checks that getGraph() returns a Graph with vertices correctly
     * connected.
     */
    @Test
    void getGraph_onCustomGraph_hasCorrectVertices() {
        Graph<Integer> expected = new AdjacencyListGraph<>();
        Random rand = new Random();
        for (int j = 0; j < NUM_ROWS * NUM_COLS; j++) {
            // horizontal edges
            if ((j + 1) % NUM_ROWS != 0) {
                expected.addUndirectedEdge(j, j + 1, rand.nextDouble());
            }
            // vertical edges
            if (j + NUM_COLS < NUM_ROWS * NUM_COLS) {
                expected.addUndirectedEdge(j, j + NUM_COLS, rand.nextDouble());
            }
        }
        assertEquals(expected.vertices(), customGraph.vertices(),
                "getGraph() does not connect vertices correctly");
    }


    /**
     * Checks that getMST() returns the correct MST.
     */
    @Test
    void getMST_onDefaultGeneratedGraph_returnsCorrectMST() {
        Set<Edge<Integer>> expectedMST = mstFinder.findMST(defaultGraph);
        assertEquals(expectedMST, defaultRB.getMST(),
                "getMST() does not return correcrt MST");
    }


    /**
     * Checks that getOptimalSolution() returns the correct list for a custom
     * Graph.
     */
    @Test
    void getOptimalSolution_onCustomGraph_returnsCorrect() {
        mstFinder.findMST(customGraph);
        Graph<Integer> kruskalGraph = mstFinder.getKruskalGraph();
        Map<Integer, Edge<Integer>> spt;
        spt = spFinder.shortestPathTree(kruskalGraph, SOURCE, TARGET);
        List<Edge<Integer>> sp = spFinder.extractShortestPath(
                spt,
                SOURCE,
                TARGET
        );
        List<Integer> res = new ArrayList<>();
        for (Edge<Integer> edge : sp) {
            res.add(edge.from());
        }
        res.add(sp.get(sp.size() - 1).to());
        assertEquals(res, customRB.getOptimalSolution(),
                "getOptimalSolution() does not return correct " +
                        "optimal solution");
    }

}